---
title: 《JavaScript高级程序设计》笔记
date: 2019-12-01 17:02:24
permalink: /pages/9f4cad/
categories:
  - 前端
  - 书籍
tags:
  - JavaScript
---

# 《JavaScript高级程序设计》笔记

## 第 1 章：JavaScript 简介
> JavaScript 诞生于 1995年。随着 Web 的流行和发展，对客户端的脚本语言需求愈加强烈，当时走在技术革新前沿的 Netscape 公司决定开发一门客户端语言满足这些需求。由此，LiveScript 诞生，当时为了搭上媒体热炒 Java 的顺风车，改名为 JavaScript。

JavaScript 由 ***核心(ECMAScript)*** 、***文档对象模型(DOM)*** 、***浏览器对象模型(BOM)*** 三部分组成。

::: theorem 核心(ECMAScript)
由于当时一开始并没有标准规定 JavaScript 的语法和特性，导致 JavaScript 产生了不同的版本(Netscape Navigator 和 微软 IE)。1997年，以 JavaScript1.1 为蓝本被提交给了欧洲计算机制造商协会，即 ECMA，由该协会指定技术委员会负责定制标准，最终完成了 ECMA-262，由 ECMA-262 定义的 ECMAScript 诞生。

- 1996 年 11 月，Netscape 公司，决定将 JavaScript 提交给国际标准化组织 ECMA。次年，ECMA发布 ECMAScript。这个版本就是 ECMAScript 1.0 版。
- 1998 年 6 月，ECMAScript 2.0 版发布。
- 1999 年 12 月，ECMAScript 3.0 版发布，成为 JavaScript 的通行标准，得到了广泛支持。
- 2007 年 10 月，ECMAScript 4.0 版草案发布，对 3.0 版做了大幅升级，但是，以 Yahoo、Microsoft、Google为首的大公司，反对 JavaScript 的大幅升级，主张小幅改动，各方分歧太大，争论过于激进，ECMA 开会决定，中止 ECMAScript 4.0 的开发
- 2009 年 12 月，ECMAScript 5.0 版正式发布。
- 2015 年 6 月，ECMAScript 6 正式通过，成为国际标准。
:::

::: theorem 文档对象模型(DOM)
> 文档对象模型是针对 XML 但经过扩展用于 HTML 的应用程序接口。DOM 把整个页面映射为一个多层节点结构。通过 DOM 提供的 API 开发者可以轻松自如的增删查改任何节点。还是由于当时 Netscape 和 微软的竞争导致标准不一，最后由负责 Web 通信标准的 W3C 制定 DOM 标准。

- DOM 级别
    1. DOM 1级，于1998.10成为 W3C 的推荐标准。该级由两个模块组成
        - DOM Core：规定如何映射基于 XML 的文档结构，以便简化对文档中的任意部分的访问和操作
        - DOM HTML：在 DOM 核心基础上加以扩展，添加针对 HTML 的对象和方法
    2. DOM 2级，在原先基础上再扩充新模块
        - DOM 视图 (DOM Views)：定义了跟踪不同文档视图的接口（如：应用 CSS 前后的文档）
        - DOM 事件 (DOM Events)：定义了事件和事件处理接口
        - DOM 样式 (DOM Style)：定义了基于 CSS 为元素应用样式的接口
        - DOM 遍历和范围：定义了遍历和操作文档树的接口
    3. DOM 3级，进一步扩展了 DOM
        - 引入了以统一方式加载和保存文档的方法
        - 新增了验证文档的方法
        - 对核心进行扩展，开始支持 XML 1.0 规范

> *除 JavaScript 外，一些其他语言也实现了 DOM，如 SVG。*
:::

::: theorem 浏览器对象模型(BOM)
> BOM 没有相关的标准，但是这个问题在 HTML5 中得到解决，HTML5 把很多 BOM 功能写入正式规范。

*根本上讲，BOM只处理浏览器窗口和框架，但人们习惯把所有针对浏览器的 JavaScript 扩展算作  BOM 的一部分。下面是一些扩展：*

- 弹出新浏览器窗口的功能
- 移动、缩放和关闭浏览器的功能
- 提供浏览器详细信息的 navigator 对象
- 提供浏览器所加载页面的详细信息的 location 对象
- 提供用户显示器分辨率详细信息的 screen 对象
- 对 cookies 的支持
- 像 XMLHttpRequest 和 IE 的 ActiveXObject 这样的自定义对象
:::

## 第 2 章：在 HTML 中使用 JavaScript
> 向 HTML 页面中插入 JavaScript 的主要方法就是利用  `<script>`元素。该元素由 Netscape 创造，后被加入到 HTML 规范中。在不使用 defer 或 async 属性的情况下，按顺序解析，一般把`<script>`元素放在内容后面`</body>`前面。`<noscript>`元素，当浏览器不支持 JavaScript 的时候，显示该元素中的内容。

::: theorem 延迟脚本和异步脚本
> *`<script>` 标签中的 defer 属性 和 async 属性。只适用于外部脚本*

1. defer 属性：用途是表明脚本在执行时不会影响页面的构造
    - 脚本立即下载
    - 脚本延迟到浏览器遇到`</html>`标签后再执行
    - 顺序执行，且会先于 DOMContentLoaded 事件执行（现实中不一定会按照顺序执行，也不一定会比 DOMContentLoaded 触发前执行。因此最好只包含一个延迟脚本）
2. async 属性：不让页面等待两个脚本的下载和执行（建议加载期间不修改DOM）
    - 脚本立即下载
    - 在页面的 load 事件前执行
    - 不顺序执行，可能会在 DOMContentLoaded 触发前后执行

> XHTML，将HTML作为XML的应用而重新定义的一个标准
:::

::: theorem 文档模式
IE5.5 引入的概念。通过文档类型（doctype）的切换实现。文档模式有 **混杂模式**、**标准模式**和**准标准模式**。HTML5 的标准模式为 `<!DOCTYPE html>`。
:::

## 第 3 章：语法基础

### 3.1 语法
- 区分大小写（***ECMAScript 中一切都区分大小写***）
- 标识符（变量、函数、属性和函数参数的名称），由 ***字母（包括ASCII、Unicode中的字母字符）*** 、***下划线（_）*** 、***美元符号（$）*** 、***数字*** 组成，不能以数字开头，且统一使用驼峰大小写形式
- 注释，单行注释（// ...）、多行注释（/* ... */）
- 严格模式（任何支持JavaScript引擎的都适用），"use strict";
- 语句，以分号结尾（标准），省略分号（由解析器确定语句结尾）

### 3.2 关键字与保留字
> 挺多的

### 3.3变量
> ECMAScript 变量是松散类型的，可以用于保存任何类型的数据。每个变量只不过是一个用于保存任意值的命名占位符。有 3 个关键字可以声明变量： var 、 const 和 let 。其中， var 在ECMAScript 的所有版本中都可以使用，而 const 和 let 只能在 ECMAScript 6及更高的版本中使用。

1. var 关键字
   - 作用域：函数级作用域，函数退出时销毁
   - 声明提升：声明的变量自动提升到函数作用域顶部，此外反复声明同一个变量也没问题
   ``` js
    function demo() {
        console.log(test); // 输出 undefined
        var test = 'test';
    }

    // 实际等同
    function demo() {
        var test;
        console.log(test);
        test = 'test';
    }
   ```
2. let 声明
    > let 跟 var 的作用差不多，但有着非常重要的区别。***最明显的区别是，let 声明的范围是块作用域，而 var 声明的范围是函数作用域。*** **let 不允许在同一作用域中出现冗余声明（SyntaxError），且不会因与var混用而受影响。**

    - 暂时性死区：let 声明的变量不会在作用域中被提升。**在解析代码时，JavaScript 引擎也会注意出现在块后面的 let 声明，只不过在此之前不能以任何方式来引用未声明的变量。在 let 声明之前的执行瞬间被称为“暂时性死区”（temporal dead zone），在此阶段引用任何后面才声明的变量都会抛出 ReferenceError**
    - 全局声明： 使用 let 在全局作用域中声明的变量不会成为 window 对象的属性（var 声明的变量则会），但是 let 声明仍然是在全局作用域中发生的，相应变量会在页面的生命周期内存续
    - 条件声明：条件声明是一种反模式，它让程序变得更难理解
    - for 循环中的 let 声明，**使用 let 声明迭代变量时，JavaScript 引擎在后台会为每个迭代循环声明一个新的迭代变量**
    ``` js
    // 在使用 var 的时候，最常见的问题就是对迭代变量的奇特声明和修改
    for (var i = 0; i < 5; ++i) {
        setTimeout(() => console.log(i), 0)
    }
    // 你可能以为会输出 0、1、2、3、4
    // 实际上会输出 5、5、5、5、5，这是因为在退出循环时，迭代变量保存的是导致循环退出的值：5
    ```
3. const 声明
    > const 的行为与 let 基本相同，唯一一个重要的区别是用 ***它声明变量时必须同时初始化变量，且尝试修改 const 声明的变量会导致运行时错误。***
4. 声明风格及最佳实践
    - 不使用 var
    - const 优先，let 次之。使用 const 声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作

### 3.4 数据类型
> ECMAScript 有6种简单数据类型（也称为原始类型）：Undefined 、 Null 、 Boolean 、 Number 、String 和 Symbol。Symbol（符号）是 ECMAScript6 新增的。还有一种复杂数据类型叫 Object（对象，是一种无序名值对的集合）。ECMAScript 中不能定义自己的数据类型，所有值都可以用上述 7 种数据类型之一来表示。

#### 3.4.1. typeof 操作符
*用于确定任意变量的数据类型。 typeof 是一个操作符而不是函数，不需要参数（但可以使用参数形式）*
- undefined，表示值未定义（未声明）
- boolean，表示值为布尔值
- string，表示值为字符串
- number，表示值为数值
- object，表示值为对象（而不是函数）或 null
- function，表示值为函数
- symbol，表示值为符号
> 严格来讲，函数在 ECMAScript 中被认为是对象，并不代表一种数据类型。可是，函数也有自己特殊的属性。为此，就有必要通过 typeof 操作符来区分函数和其他对象。

#### 3.4.2. undefined 类型
> 只有一个值，即特殊值 undefined。***默认情况下，任何未经初始化的变量都会取得 undefined 值（不需要显式声明）。*** **增加这个特殊值的目的就是为了正式明确空对象指针（null）和未初始化变量的区别。**

#### 3.4.3. Null 类型
>只有一个值，即特殊值 null，表示一个空对象指针 **（当声明变量为对象类型且值暂时为空时，要使用null来填充，以区分普通值类型）**。这也是给 typeof 传一个 null 会返回 "object" 的原因。*undefined 值是由 null 值派生而来的，因此 ECMA-262 将它们定义为表面上相等，全等(===)则返回false*。

#### 3.4.4. boolean 类型（true or false）
> Boolean() 转型函数可以在任意类型的数据上调用，而且始终返回一个布尔值。像 if 等流控制语句会自动执行Boolean()，将其他类型值转换为布尔值

| 数据类型 | 转换为 true 的值 | 转换为 false 的值 |
| :------: | :--------------: | :---------------: |
| Boolean  | true             | false             |
| String   | 非空字符串       | ""（空字符串）    |
| Number   | 非零数值（包括无穷值）| 0 、 NaN     |
| Object   | 任意对象         | null              |
| Undefined| N/A （不存在）   | undefined         |

#### 3.4.5. Number 类型
> Number 类型使用 IEEE 754格式表示整数和浮点值（在某些语言中也叫双精度值）。
::: theorem 浮点数
> 定义浮点数，数值必须包含小数点且至少有个不为零的小数（由于浮点数值使用的内存空间是整数数值的两倍，所以 ECMAScript 总是想方设法把值转换为整数）

> 科学计数法，ECMAScript 中科学记数法的格式要求是一个数值（整数或浮点数）后跟一个大写或小写的字母 e，再加上一个要乘的 10 的多少次幂。*如：let floatNum = 3.125e+7; // 等于 31250000*

> 精度丢失，浮点值的精确度最高可达 17 位小数，但在算术计算中远不如整数精确。如：0.1 + 0.2。***因此永远不要测试某个特定的浮点值***（之所以存在这种舍入错误，是因为使用了 IEEE 754数值，这种错误并非 ECMAScript 所独有。其他使用相同格式的语言也有这个问题）
:::

::: theorem 值的范围
> 如果计算返回正 Infinity 或 -Infinity ，则该值将不能再进一步用于任何计算。这是因为 Infinity 没有可用于计算的数值表示形式。要确定一个值是不是有限大（即介于 JavaScript 能表示的最小值和最大值之间），可以使用 isFinite() 函数

- 最大值：Number.MAX_VALUE
- 最小值：Number.MIN_VALUE
- 无穷大（Infinity or Number.POSITIVE_INFINITY）
- 无穷小（-Infinity or Number.NEGATIVE_INFINITY）
:::

::: theorem NaN
> 有一个特殊的数值叫 NaN（Not a Number），用于表示本来要返回数值的操作失败了（而不是抛出错误）。比如，用 0 除任意数值在其他语言中通常都会导致错误，从而中止代码执行。但在 ECMAScript 中，0、+0 或 -0 相除会返回 NaN

- ±0 / ±0 = NaN 
- 任何涉及 NaN 的操作始终返回 NaN
- NaN 不等于包括 NaN 在内的任何值

> 为此，ECMAScript 提供了 isNaN() 函数，**任何不能转换为数值的值都会导致这个函数返回 true**
:::

::: theorem 数值转换
> Number()， 是转型函数，可用于任何数据类型，规则如下：
- 数值，直接返回
- null，返回 0
- undefined，返回 NaN
- 布尔值， true 转换为 1， false 转换为 0
- 字符串，应用以下规则：
    - 如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为十进制数值
        - Number("±1") 返回 ±1
        - Number("123") 返回 123
        - Number("011") 返回 11（忽略前面的零）
    - 如果字符串包含有效的浮点值格式如 "1.1" ，则会转换为相应的浮点值（同样，忽略前面的零）
    - 如果字符串包含有效的十六进制格式如 "0xf" ，则会转换为与该十六进制值对应的十进制整数值
    - 如果是空字符串（不包含字符），则返回 0
    - 如果字符串包含除上述情况之外的其他字符，则返回 NaN
        - Number("c10") 返回 NaN
        - Number("1c0") 返回 NaN
        - Number("10c") 返回 NaN
- 对象，调用 valueOf() 方法，并按照上述规则转换返回的值。如果转换结果是 NaN ，则调用 toString() 方法，再按照转换字符串的规则转换
> parseInt() 函数更专注于字符串是否包含数值模式。字符串最前面的空格会被忽略，从第一个非空格字符开始转换。**如果第一个字符不是数值字符、加号或减号， parseInt() 立即返回 NaN。** parseInt() 也接收第二个参数，用于指定底数（进制数）。**如果知道要解析的值是十六进制，那么可以传入 16 作为第二个参数（返回十进制数）**

> parseFloat() 函数的工作方式跟 parseInt() 函数类似，不同的是**它能解析第一次出现的小数点，始终忽略字符串开头的零，且只解析十进制值（只有一个参数）**
:::

#### 3.4.6. string 类型
> 表示零或多个 16 位 Unicode 字符序列。字符串可以使用双引号（"）、单引号（'）或反引号（`）开始并结束

::: theorem 字符字面量
> 字符串数据类型包含一些字符字面量，用于表示非打印字符或有其他用途的字符，可以出现在字符串中的任意位置，且可以作为**单个字符**被解释

|       字面量      |       含义        |
|:-----------------:|:-----------------:|
|\n                 |换行               |
|\t                 |制表               |
|\b                 |退格               |
|\r                 |回车               |
|\f                 |换页               |
|\\\                |反斜杠（\）        |
|\\'                |单引号（'）        |
|\\"                |单引号（"）        |
|\\\`               |单引号（`）        |
|\xnn               |以十六进制编码 nn 表示的字符（其中 n 是十六进制数字 0~F），例如 \x41 等于 "A"|
|\unnnn             |以十六进制编码 nnnn 表示的 Unicode 字符（其中 n 是十六进制数字 0~F），例如 \u03a3 等于希腊字符 "Σ"|
> 字符串的长度可以通过其 length 属性获取。**如果字符串中包含双字节字符，那么 length 属性返回的值可能不是准确的字符数（返回的是字符串长度）。**
:::

::: theorem 字符串的特点
> ECMAScript 中的字符串是不可变的（immutable），意思是一旦创建，它们的值就不能变了。**要修改某个变量中的字符串值，先分配新的空间、填充值保存，然后销毁原始的字符串，最后将包含新值的字符串保存到该变量**

> String 实现 Iterator 接口，所以字符串也可以像 Array 类型那样具有遍历等操作，如 str[0]
:::

::: theorem 转换为字符串
> 有两种方式把一个值转换为字符串。**首先是使用几乎所有值都有的 toString() 方法（null、undefined没有）**，这个方法唯一的用途就是返回当前值的字符串等价物。另一种则是 String()。

- toString()，对数值调用这个方法时，可以接收一个底数参数，以什么底数来输出数值的字符串表示。默认十进制
- String()，如果不确定一个值是不是 null 或 undefined ，可以使用 String() 转型函数，遵循如下原则：
    - 如果值有 toString() 方法，则调用该方法（不传参数）并返回结果
    - 如果值是 null ，返回 "null"
    - 如果值是 undefined ，返回 "undefined"
- 用加号操作符给一个值加上一个空字符串 "" 也可以将其转换为字符串
:::

::: theorem 模板字面量
> ECMAScript 6 新增了使用模板字面量定义字符串的能力。**与使用单引号或双引号不同，模板字面量（反引号）保留换行字符，可以跨行定义字符串**，最常用的一个特性是支持字符串插值（技术上讲，模板字面量不是字符串，而是一种特殊的 JavaScript 句法表达式，只不过求值后得到的是字符串）

- 字符串插值
    - 使用 ${} 符号插入一个或多个变量
    - 插入的值都会使用 toString() 强制转型为字符串
    - 任何 JavaScript 表达式都可以用于插值
- 定义标签函数（自定义插值行为，太复杂，不想了解）
- 直接获取原始的模板字面量内容（不想了解）
:::

#### 3.4.7. Symbol 类型
> Symbol （符号）是 ECMAScript 6 新增的数据类型。**符号是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险**。符号就是用来创建唯一记号，进而用作非字符串形式的对象属性。

#### 3.4.8 Object 类型
> ECMAScript 中的对象其实就是一组数据和功能的集合，类似 Java 中的 java.lang.Object，ECMAScript中的 Object 也是派生其他对象的基类

每个 Object 实例都有如下属性和方法：
- ***constructor()*** ：用于创建当前对象的函数
- ***hasOwnProperty(propertyName: string | symbol)*** ：用于判断当前对象实例（不是原型）上是否存在给定的属性
- ***isPrototypeOf(object)*** ：用于判断当前对象是否为另一个对象的原型
- ***propertyIsEnumerable(propertyName: string | symbol)*** ：用于判断给定的属性是否可以使用
- ***toLocaleString()*** ：返回对象的字符串表示，该字符串反映对象所在的本地化执行环境
- ***toString()*** ：返回对象的字符串表示（1234转换为'1234'，而toLocaleString转为'1,234'；时间格式）
- ***valueOf()*** ：返回对象对应的字符串、数值或布尔值表示（通常与 toString() 的返回值相同）

### 3.5 操作符
- 一元操作符（+、-、*、/、%、++、-- 等）
- 位操作符，ECMAScript中的所有数值都以 IEEE 754 64位格式存储，**先把值转换为32位整数，进行位操作，之后再把结果转换为64位**（~、&、|、^、<<、>>、>>> 等）
    - 符号位，第32位表示符号（0表示正，1表示负）
    - 正数（符号位（0）＋|值|），原码 = 补码 = 反码
    - 负数（符号位（1）＋|值|），补码 = 原码取反加1，反码 = 原码取反 
    - 负值 = |值| -> 取反 -> 加1 ***（这样和正数加起来刚好进位为零）***
    - **特殊值 NaN 和 ±Infinity 在位操作中都会被当成 0 处理**
    - 将位操作符应用到非数值，那么首先会使用 Number() 函数将该值转换为数值（这个过程是自动的），然后再应用位操作。**最终结果是数值**
- 布尔操作符（!、&&、||）
    - 逻辑非（!），首先将操作数转换为布尔值，然后再对其取反。遵循如下规则：
        - !true = false
        - !false = true
    - 逻辑与（&&），逻辑与操作符可用于任何类型的操作数，不限于布尔值。遵循如下规则：
        - 如果Boolean(第一个操作数) === true，则返回第二个操作数
        - 如果Boolean(第一个操作数) === false，则返回第一个操作数
    - 逻辑或（||），与逻辑与相似。遵循如下规则：
        - 如果Boolean(第一个操作数) === true，则返回第一个操作数
        - 如果Boolean(第一个操作数) === false，则返回第二个操作数
- 乘性操作符（*、/、%），乘、除、取模，有以下几种特殊情况：
    - 任一操作数是NaN，则返回NaN
    - ±Infinity / ±Infinity 和 ±0 / ±0，返回NaN
    - ±Infinity % any 和 any % 0，返回NaN
    - 如果有不是数值的操作数，则先在后台用 Number() 函数将其转换为数值后计算
- 指数操作符（**），ECMAScript 7新增了指数操作符， Math.pow() 现在有了自己的操作符 **，指数赋值操作符 **=
- 加性操作符（+、-），加减，有以下几种特殊情况：
    - 任一操作数是 NaN ，则返回 NaN
    -  Infinity 加 -Infinity ，则返回 NaN
    -  ±Infinity 减 ±Infinity ，则返回 NaN
- 关系操作符（<、>、<=、>=），遵循如下规则：
    - **如果任一操作数是NaN，则返回false**
    - 如果操作数都是数值，则执行数值比较
    - 如果操作数都是字符串，则逐个比较字符串中对应字符的编码
    - 如果有任一操作数是数值，则将另一个操作数转换为数值，执行数值比较
    - 如果有任一操作数是布尔值，则将其转换为数值再执行比较
    - 对象，valueOf() || toString()
- 相等操作符（==、!=、===、!==），全等不会进行类型转换
- 条件操作符（Boolean(...) ? true : false）
- 赋值操作符（=、+=、-=、*=、/=、%=、<<=、>>=、>>>=），仅仅是简写语法，使用它们不会提升性能
- 逗号操作符（,）let num1 = 1, num2 = 2, num3 = 3;

### 3.6 语句
> ECMAScript 会自动调用 Boolean() 函数将判断条件中的值转换为布尔值

- if 语句
- do-while 语句，至少执行一次循环
- while 语句，先测试语句，先检测退出条件，后执行
- for 语句，也是先测试语句，只不过增加了进入循环之前的初始化代码，以及循环执行后要执行的表达式
- for-in 语句，遍历对象中的非符号键属性。要迭代的变量是 null 或 undefined ，则不执行循环体
- for-of 语句，遍历可迭代对象的元素（数组、对象），若变量不支持迭代，则 for-of 语句会抛出错误
> ES2018 对 for-of 语句进行了扩展，增加了 for-await-of 循环，以支持生成期约（promise）的异步可迭代对象

- 标签语句，配合 break 或 continue 使用
- break 和 continue 语句， break 语句用于立即退出循环，强制执行循环后的下一条语句。continue 语句也用于立即退出循环，但会再次从循环顶部开始执行
- with 语句，用途是将代码作用域设置为特定的对象 **（严格模式不允许使用 with 语句，否则会抛出错误）**
``` js
const qs = location.search.substring(1);
const hostName = location.hostname;
const url = location.href;

// 使用with。with 语句影响性能且难于调试其中的代码，通常不推荐在产品代码中使用 with 语句
with(location) {
    const qs = search.substring(1);
    const hostName = hostname;
    const url = href;
}
```
- switch 语句，可以用于所有数据类型（在很多语言中，它只能用于数值）；条件的值不需要是常量，也可以是变量或表达式

### 3.7 函数
> ECMAScript 中的函数使用 function 关键字声明，后跟一组参数，然后是函数体。return 语句可以不带返回值。这时候，函数会立即停止执行并返回 undefined 。这种用法最常用于提前终止函数执行，并不是为了返回值

## 第 4 章：变量、作用域与内存

::: theorem 原始值和引用值
> ECMAScript 变量可以包含两种不同类型的数据：原始值（六种基本类型，直接操作实际值）和引用值（对象，实际值在堆内存中，通过引用访问操作）。**把一个值赋给变量时，JavaScript 引擎必须确定这个值是原始值还是引用值。**

- 原始值
    - 动态属性：无
    - 复制值：直接复制，值之间完全独立
    - 传递参数：与复制值相同，将值复制到函数内部的参数变量中

- 引用值
    - 动态属性：可随时添加、修改和删除其属性和方法
    - 复制值：复制的值实际上是个指针，指向堆内存中的对象
    - 传递参数：与复制值相同，将指针指向对象内存地址的值，复制给函数内部的参数变量中（理解引用和指针）
        - 引用：指的是存储在堆内存中的对象（暂）
        - 指针：指向堆内存对象的地址值（暂）
:::

::: theorem 执行上下文与作用域

:::

::: theorem 垃圾回收

:::
