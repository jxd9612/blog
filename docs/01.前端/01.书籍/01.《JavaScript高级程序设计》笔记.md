---
title: 《JavaScript高级程序设计》笔记
date: 2019-12-01 17:02:24
permalink: /pages/9f4cad/
categories:
  - 前端
  - 书籍
tags:
  - JavaScript
---

# 《JavaScript高级程序设计》笔记

## 第 1 章：JavaScript 简介
> JavaScript 诞生于 1995年。随着 Web 的流行和发展，对客户端的脚本语言需求愈加强烈，当时走在技术革新前沿的 Netscape 公司决定开发一门客户端语言满足这些需求。由此，LiveScript 诞生，当时为了搭上媒体热炒 Java 的顺风车，改名为 JavaScript。

JavaScript 由 ***核心(ECMAScript)*** 、***文档对象模型(DOM)*** 、***浏览器对象模型(BOM)*** 三部分组成。

::: theorem 核心(ECMAScript)
由于当时一开始并没有标准规定 JavaScript 的语法和特性，导致 JavaScript 产生了不同的版本(Netscape Navigator 和 微软 IE)。1997年，以 JavaScript1.1 为蓝本被提交给了欧洲计算机制造商协会，即 ECMA，由该协会指定技术委员会负责定制标准，最终完成了 ECMA-262，由 ECMA-262 定义的 ECMAScript 诞生。

- 1996 年 11 月，Netscape 公司，决定将 JavaScript 提交给国际标准化组织 ECMA。次年，ECMA发布 ECMAScript。这个版本就是 ECMAScript 1.0 版。
- 1998 年 6 月，ECMAScript 2.0 版发布。
- 1999 年 12 月，ECMAScript 3.0 版发布，成为 JavaScript 的通行标准，得到了广泛支持。
- 2007 年 10 月，ECMAScript 4.0 版草案发布，对 3.0 版做了大幅升级，但是，以 Yahoo、Microsoft、Google为首的大公司，反对 JavaScript 的大幅升级，主张小幅改动，各方分歧太大，争论过于激进，ECMA 开会决定，中止 ECMAScript 4.0 的开发
- 2009 年 12 月，ECMAScript 5.0 版正式发布。
- 2015 年 6 月，ECMAScript 6 正式通过，成为国际标准。
:::

::: theorem 文档对象模型(DOM)
> 文档对象模型是针对 XML 但经过扩展用于 HTML 的应用程序接口。DOM 把整个页面映射为一个多层节点结构。通过 DOM 提供的 API 开发者可以轻松自如的增删查改任何节点。还是由于当时 Netscape 和 微软的竞争导致标准不一，最后由负责 Web 通信标准的 W3C 制定 DOM 标准。

- DOM 级别
    1. DOM 1级，于1998.10成为 W3C 的推荐标准。该级由两个模块组成
        - DOM Core：规定如何映射基于 XML 的文档结构，以便简化对文档中的任意部分的访问和操作
        - DOM HTML：在 DOM 核心基础上加以扩展，添加针对 HTML 的对象和方法
    2. DOM 2级，在原先基础上再扩充新模块
        - DOM 视图 (DOM Views)：定义了跟踪不同文档视图的接口（如：应用 CSS 前后的文档）
        - DOM 事件 (DOM Events)：定义了事件和事件处理接口
        - DOM 样式 (DOM Style)：定义了基于 CSS 为元素应用样式的接口
        - DOM 遍历和范围：定义了遍历和操作文档树的接口
    3. DOM 3级，进一步扩展了 DOM
        - 引入了以统一方式加载和保存文档的方法
        - 新增了验证文档的方法
        - 对核心进行扩展，开始支持 XML 1.0 规范

> *除 JavaScript 外，一些其他语言也实现了 DOM，如 SVG。*
:::

::: theorem 浏览器对象模型(BOM)
> BOM 没有相关的标准，但是这个问题在 HTML5 中得到解决，HTML5 把很多 BOM 功能写入正式规范。

*根本上讲，BOM只处理浏览器窗口和框架，但人们习惯把所有针对浏览器的 JavaScript 扩展算作  BOM 的一部分。下面是一些扩展：*

- 弹出新浏览器窗口的功能
- 移动、缩放和关闭浏览器的功能
- 提供浏览器详细信息的 navigator 对象
- 提供浏览器所加载页面的详细信息的 location 对象
- 提供用户显示器分辨率详细信息的 screen 对象
- 对 cookies 的支持
- 像 XMLHttpRequest 和 IE 的 ActiveXObject 这样的自定义对象
:::

## 第 2 章：在 HTML 中使用 JavaScript
> 向 HTML 页面中插入 JavaScript 的主要方法就是利用  `<script>`元素。该元素由 Netscape 创造，后被加入到 HTML 规范中。在不使用 defer 或 async 属性的情况下，按顺序解析，一般把`<script>`元素放在内容后面`</body>`前面。`<noscript>`元素，当浏览器不支持 JavaScript 的时候，显示该元素中的内容。

::: theorem 延迟脚本和异步脚本
> *`<script>` 标签中的 defer 属性 和 async 属性。只适用于外部脚本*

1. defer 属性：用途是表明脚本在执行时不会影响页面的构造
    - 脚本立即下载
    - 脚本延迟到浏览器遇到`</html>`标签后再执行
    - 顺序执行，且会先于 DOMContentLoaded 事件执行（现实中不一定会按照顺序执行，也不一定会比 DOMContentLoaded 触发前执行。因此最好只包含一个延迟脚本）
2. async 属性：不让页面等待两个脚本的下载和执行（建议加载期间不修改DOM）
    - 脚本立即下载
    - 在页面的 load 事件前执行
    - 不顺序执行，可能会在 DOMContentLoaded 触发前后执行

> XHTML，将HTML作为XML的应用而重新定义的一个标准
:::

::: theorem 文档模式
IE5.5 引入的概念。通过文档类型（doctype）的切换实现。文档模式有 **混杂模式**、**标准模式**和**准标准模式**。HTML5 的标准模式为 `<!DOCTYPE html>`。
:::

## 第 3 章：语法基础

### 3.1 语法
- 区分大小写（***ECMAScript 中一切都区分大小写***）
- 标识符（变量、函数、属性和函数参数的名称），由 ***字母（包括ASCII、Unicode中的字母字符）*** 、***下划线（_）*** 、***美元符号（$）*** 、***数字*** 组成，不能以数字开头，且统一使用驼峰大小写形式
- 注释，单行注释（// ...）、多行注释（/* ... */）
- 严格模式（任何支持JavaScript引擎的都适用），"use strict";
- 语句，以分号结尾（标准），省略分号（由解析器确定语句结尾）

### 3.2 关键字与保留字
> 挺多的

### 3.3变量
> ECMAScript 变量是松散类型的，可以用于保存任何类型的数据。每个变量只不过是一个用于保存任意值的命名占位符。有 3 个关键字可以声明变量： var 、 const 和 let 。其中， var 在ECMAScript 的所有版本中都可以使用，而 const 和 let 只能在 ECMAScript 6及更高的版本中使用。

1. var 关键字
   - 作用域：函数级作用域，函数退出时销毁
   - 声明提升：声明的变量自动提升到函数作用域顶部，此外反复声明同一个变量也没问题
   ``` js
    function demo() {
        console.log(test); // 输出 undefined
        var test = 'test';
    }

    // 实际等同
    function demo() {
        var test;
        console.log(test);
        test = 'test';
    }
   ```
2. let 声明
    > let 跟 var 的作用差不多，但有着非常重要的区别。***最明显的区别是，let 声明的范围是块作用域，而 var 声明的范围是函数作用域。*** **let 不允许在同一作用域中出现冗余声明（SyntaxError），且不会因与var混用而受影响。**

    - 暂时性死区：let 声明的变量不会在作用域中被提升。**在解析代码时，JavaScript 引擎也会注意出现在块后面的 let 声明，只不过在此之前不能以任何方式来引用未声明的变量。在 let 声明之前的执行瞬间被称为“暂时性死区”（temporal dead zone），在此阶段引用任何后面才声明的变量都会抛出 ReferenceError**
    - 全局声明： 使用 let 在全局作用域中声明的变量不会成为 window 对象的属性（var 声明的变量则会），但是 let 声明仍然是在全局作用域中发生的，相应变量会在页面的生命周期内存续
    - 条件声明：条件声明是一种反模式，它让程序变得更难理解
    - for 循环中的 let 声明，**使用 let 声明迭代变量时，JavaScript 引擎在后台会为每个迭代循环声明一个新的迭代变量**
    ``` js
    // 在使用 var 的时候，最常见的问题就是对迭代变量的奇特声明和修改
    for (var i = 0; i < 5; ++i) {
        setTimeout(() => console.log(i), 0)
    }
    // 你可能以为会输出 0、1、2、3、4
    // 实际上会输出 5、5、5、5、5，这是因为在退出循环时，迭代变量保存的是导致循环退出的值：5
    ```
3. const 声明
    > const 的行为与 let 基本相同，唯一一个重要的区别是用 ***它声明变量时必须同时初始化变量，且尝试修改 const 声明的变量会导致运行时错误。***
4. 声明风格及最佳实践
    - 不使用 var
    - const 优先，let 次之。使用 const 声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作

### 3.4 数据类型
> ECMAScript 有6种简单数据类型（也称为原始类型）：Undefined 、 Null 、 Boolean 、 Number 、String 和 Symbol。Symbol（符号）是 ECMAScript6 新增的。还有一种复杂数据类型叫 Object（对象，是一种无序名值对的集合）。ECMAScript 中不能定义自己的数据类型，所有值都可以用上述 7 种数据类型之一来表示。

#### 3.4.1. typeof 操作符
*用于确定任意变量的数据类型。 typeof 是一个操作符而不是函数，不需要参数（但可以使用参数形式）*
- undefined，表示值未定义（未声明）
- boolean，表示值为布尔值
- string，表示值为字符串
- number，表示值为数值
- object，表示值为对象（而不是函数）或 null
- function，表示值为函数
- symbol，表示值为符号
> 严格来讲，函数在 ECMAScript 中被认为是对象，并不代表一种数据类型。可是，函数也有自己特殊的属性。为此，就有必要通过 typeof 操作符来区分函数和其他对象。

#### 3.4.2. undefined 类型
> 只有一个值，即特殊值 undefined。***默认情况下，任何未经初始化的变量都会取得 undefined 值（不需要显式声明）。*** **增加这个特殊值的目的就是为了正式明确空对象指针（null）和未初始化变量的区别。**

#### 3.4.3. Null 类型
>只有一个值，即特殊值 null，表示一个空对象指针 **（当声明变量为对象类型且值暂时为空时，要使用null来填充，以区分普通值类型）**。这也是给 typeof 传一个 null 会返回 "object" 的原因。*undefined 值是由 null 值派生而来的，因此 ECMA-262 将它们定义为表面上相等，全等(===)则返回false*。

#### 3.4.4. boolean 类型（true or false）
> Boolean() 转型函数可以在任意类型的数据上调用，而且始终返回一个布尔值。像 if 等流控制语句会自动执行Boolean()，将其他类型值转换为布尔值

| 数据类型 | 转换为 true 的值 | 转换为 false 的值 |
| :------: | :--------------: | :---------------: |
| Boolean  | true             | false             |
| String   | 非空字符串       | ""（空字符串）    |
| Number   | 非零数值（包括无穷值）| 0 、 NaN     |
| Object   | 任意对象         | null              |
| Undefined| N/A （不存在）   | undefined         |

#### 3.4.5. Number 类型
> Number 类型使用 IEEE 754格式表示整数和浮点值（在某些语言中也叫双精度值）。
::: theorem 浮点数
> 定义浮点数，数值必须包含小数点且至少有个不为零的小数（由于浮点数值使用的内存空间是整数数值的两倍，所以 ECMAScript 总是想方设法把值转换为整数）

> 科学计数法，ECMAScript 中科学记数法的格式要求是一个数值（整数或浮点数）后跟一个大写或小写的字母 e，再加上一个要乘的 10 的多少次幂。*如：let floatNum = 3.125e+7; // 等于 31250000*

> 精度丢失，浮点值的精确度最高可达 17 位小数，但在算术计算中远不如整数精确。如：0.1 + 0.2。***因此永远不要测试某个特定的浮点值***（之所以存在这种舍入错误，是因为使用了 IEEE 754数值，这种错误并非 ECMAScript 所独有。其他使用相同格式的语言也有这个问题）
:::

::: theorem 值的范围
> 如果计算返回正 Infinity 或 -Infinity ，则该值将不能再进一步用于任何计算。这是因为 Infinity 没有可用于计算的数值表示形式。要确定一个值是不是有限大（即介于 JavaScript 能表示的最小值和最大值之间），可以使用 isFinite() 函数

- 最大值：Number.MAX_VALUE
- 最小值：Number.MIN_VALUE
- 无穷大（Infinity or Number.POSITIVE_INFINITY）
- 无穷小（-Infinity or Number.NEGATIVE_INFINITY）
:::

::: theorem NaN
> 有一个特殊的数值叫 NaN（Not a Number），用于表示本来要返回数值的操作失败了（而不是抛出错误）。比如，用 0 除任意数值在其他语言中通常都会导致错误，从而中止代码执行。但在 ECMAScript 中，0、+0 或 -0 相除会返回 NaN

- ±0 / ±0 = NaN 
- 任何涉及 NaN 的操作始终返回 NaN
- NaN 不等于包括 NaN 在内的任何值

> 为此，ECMAScript 提供了 isNaN() 函数，**任何不能转换为数值的值都会导致这个函数返回 true**
:::

::: theorem 数值转换
> Number()， 是转型函数，可用于任何数据类型，规则如下：
- 数值，直接返回
- null，返回 0
- undefined，返回 NaN
- 布尔值， true 转换为 1， false 转换为 0
- 字符串，应用以下规则：
    - 如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为十进制数值
        - Number("±1") 返回 ±1
        - Number("123") 返回 123
        - Number("011") 返回 11（忽略前面的零）
    - 如果字符串包含有效的浮点值格式如 "1.1" ，则会转换为相应的浮点值（同样，忽略前面的零）
    - 如果字符串包含有效的十六进制格式如 "0xf" ，则会转换为与该十六进制值对应的十进制整数值
    - 如果是空字符串（不包含字符），则返回 0
    - 如果字符串包含除上述情况之外的其他字符，则返回 NaN
        - Number("c10") 返回 NaN
        - Number("1c0") 返回 NaN
        - Number("10c") 返回 NaN
- 对象，调用 valueOf() 方法，并按照上述规则转换返回的值。如果转换结果是 NaN ，则调用 toString() 方法，再按照转换字符串的规则转换
> parseInt() 函数更专注于字符串是否包含数值模式。字符串最前面的空格会被忽略，从第一个非空格字符开始转换。**如果第一个字符不是数值字符、加号或减号， parseInt() 立即返回 NaN。** parseInt() 也接收第二个参数，用于指定底数（进制数）。**如果知道要解析的值是十六进制，那么可以传入 16 作为第二个参数**

> parseFloat() 函数的工作方式跟 parseInt() 函数类似，不同的是**它能解析第一次出现的小数点，始终忽略字符串开头的零，且只解析十进制值（只有一个参数）**
:::

#### 3.4.6. string 类型
> 表示零或多个 16 位 Unicode 字符序列。字符串可以使用双引号（"）、单引号（'）或反引号（`）开始并结束

::: theorem 字符字面量
> 字符串数据类型包含一些字符字面量，用于表示非打印字符或有其他用途的字符，可以出现在字符串中的任意位置，且可以作为**单个字符**被解释

|       字面量      |       含义        |
|:-----------------:|:-----------------:|
|\n                 |换行               |
|\t                 |制表               |
|\b                 |退格               |
|\r                 |回车               |
|\f                 |换页               |
|\\\                |反斜杠（\）        |
|\\'                |单引号（'）        |
|\\"                |单引号（"）        |
|\\\`               |单引号（`）        |
|\xnn               |以十六进制编码 nn 表示的字符（其中 n 是十六进制数字 0~F），例如 \x41 等于 "A"|
|\unnnn             |以十六进制编码 nnnn 表示的 Unicode 字符（其中 n 是十六进制数字 0~F），例如 \u03a3 等于希腊字符 "Σ"|
> 字符串的长度可以通过其 length 属性获取。**如果字符串中包含双字节字符，那么 length 属性返回的值可能不是准确的字符数（返回的是字符串长度）。**
:::

::: theorem 字符串的特点
> ECMAScript 中的字符串是不可变的（immutable），意思是一旦创建，它们的值就不能变了。**要修改某个变量中的字符串值，先分配新的空间、填充值保存，然后销毁原始的字符串，最后将包含新值的字符串保存到该变量**
:::

::: theorem 转换为字符串
> 有两种方式把一个值转换为字符串。**首先是使用几乎所有值都有的 toString() 方法（null、undefined没有）**，这个方法唯一的用途就是返回当前值的字符串等价物。另一种则是 String()。

- toString()，对数值调用这个方法时，可以接收一个底数参数，以什么底数来输出数值的字符串表示。默认十进制
- String()，如果不确定一个值是不是 null 或 undefined ，可以使用 String() 转型函数，遵循如下原则：
    - 如果值有 toString() 方法，则调用该方法（不传参数）并返回结果
    - 如果值是 null ，返回 "null"
    - 如果值是 undefined ，返回 "undefined"

:::
